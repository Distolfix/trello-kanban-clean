import { getDatabase } from './database';
import type { Board, List, Card, Setting, User, CardRow, KanbanCardData, KanbanListData } from './types';

export class DatabaseService {
  private db = getDatabase();

  // Board operations
  getBoard(id: string): Board | undefined {
    const stmt = this.db.prepare('SELECT * FROM boards WHERE id = ?');
    return stmt.get(id) as Board | undefined;
  }

  getAllBoards(): Board[] {
    const stmt = this.db.prepare('SELECT * FROM boards ORDER BY updated_at DESC');
    return stmt.all() as Board[];
  }

  createBoard(board: Omit<Board, 'created_at' | 'updated_at'>): Board {
    const stmt = this.db.prepare(`
      INSERT INTO boards (id, name)
      VALUES (?, ?)
      RETURNING *
    `);
    return stmt.get(board.id, board.name) as Board;
  }

  updateBoard(id: string, updates: Partial<Pick<Board, 'name'>>): Board | undefined {
    const stmt = this.db.prepare(`
      UPDATE boards
      SET name = COALESCE(?, name)
      WHERE id = ?
      RETURNING *
    `);
    return stmt.get(updates.name, id) as Board | undefined;
  }

  deleteBoard(id: string): boolean {
    const stmt = this.db.prepare('DELETE FROM boards WHERE id = ?');
    return stmt.run(id).changes > 0;
  }

  // List operations
  getListsByBoard(boardId: string): KanbanListData[] {
    const listsStmt = this.db.prepare(`
      SELECT * FROM lists
      WHERE board_id = ?
      ORDER BY position ASC
    `);
    const lists = listsStmt.all(boardId) as List[];

    const cardsStmt = this.db.prepare(`
      SELECT c.* FROM cards c
      JOIN lists l ON c.list_id = l.id
      WHERE l.board_id = ?
      ORDER BY c.position ASC
    `);
    const allCards = cardsStmt.all(boardId) as CardRow[];

    return lists.map(list => ({
      id: list.id,
      title: list.title,
      type: list.type,
      cardLimit: list.card_limit || undefined,
      cards: allCards
        .filter(card => card.list_id === list.id)
        .map(this.convertCardRowToKanbanCard)
    }));
  }

  createList(list: Omit<List, 'created_at' | 'updated_at'>): List {
    const stmt = this.db.prepare(`
      INSERT INTO lists (id, board_id, title, type, position, card_limit)
      VALUES (?, ?, ?, ?, ?, ?)
      RETURNING *
    `);
    return stmt.get(
      list.id,
      list.board_id,
      list.title,
      list.type,
      list.position,
      list.card_limit || null
    ) as List;
  }

  updateList(id: string, updates: Partial<Pick<List, 'title' | 'type' | 'position' | 'card_limit'>>): List | undefined {
    const stmt = this.db.prepare(`
      UPDATE lists
      SET title = COALESCE(?, title),
          type = COALESCE(?, type),
          position = COALESCE(?, position),
          card_limit = COALESCE(?, card_limit)
      WHERE id = ?
      RETURNING *
    `);
    return stmt.get(
      updates.title,
      updates.type,
      updates.position,
      updates.card_limit,
      id
    ) as List | undefined;
  }

  deleteList(id: string): boolean {
    const stmt = this.db.prepare('DELETE FROM lists WHERE id = ?');
    return stmt.run(id).changes > 0;
  }

  // Card operations
  createCard(card: Omit<Card, 'created_at' | 'updated_at'>): Card {
    const stmt = this.db.prepare(`
      INSERT INTO cards (id, list_id, title, description, position, due_date, labels, attachments, members)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      RETURNING *
    `);
    return stmt.get(
      card.id,
      card.list_id,
      card.title,
      card.description || null,
      card.position,
      card.due_date || null,
      card.labels ? JSON.stringify(card.labels) : null,
      card.attachments ? JSON.stringify(card.attachments) : null,
      card.members ? JSON.stringify(card.members) : null
    ) as Card;
  }

  updateCard(id: string, updates: Partial<Pick<Card, 'title' | 'description' | 'position' | 'due_date' | 'labels' | 'attachments' | 'members' | 'list_id'>>): Card | undefined {
    const stmt = this.db.prepare(`
      UPDATE cards
      SET title = COALESCE(?, title),
          description = COALESCE(?, description),
          position = COALESCE(?, position),
          due_date = COALESCE(?, due_date),
          labels = COALESCE(?, labels),
          attachments = COALESCE(?, attachments),
          members = COALESCE(?, members),
          list_id = COALESCE(?, list_id)
      WHERE id = ?
      RETURNING *
    `);
    return stmt.get(
      updates.title,
      updates.description,
      updates.position,
      updates.due_date,
      updates.labels ? JSON.stringify(updates.labels) : null,
      updates.attachments ? JSON.stringify(updates.attachments) : null,
      updates.members ? JSON.stringify(updates.members) : null,
      updates.list_id,
      id
    ) as Card | undefined;
  }

  deleteCard(id: string): boolean {
    const stmt = this.db.prepare('DELETE FROM cards WHERE id = ?');
    return stmt.run(id).changes > 0;
  }

  // Batch update for drag and drop
  updateCardsPositions(cards: Array<{ id: string; list_id?: string; position: number }>): void {
    const stmt = this.db.prepare(`
      UPDATE cards
      SET position = ?, list_id = COALESCE(?, list_id)
      WHERE id = ?
    `);

    const transaction = this.db.transaction((cards: typeof cards) => {
      for (const card of cards) {
        stmt.run(card.position, card.list_id, card.id);
      }
    });

    transaction(cards);
  }

  updateListsPositions(lists: Array<{ id: string; position: number }>): void {
    const stmt = this.db.prepare('UPDATE lists SET position = ? WHERE id = ?');

    const transaction = this.db.transaction((lists: typeof lists) => {
      for (const list of lists) {
        stmt.run(list.position, list.id);
      }
    });

    transaction(lists);
  }

  // Settings operations
  getSetting(key: string): Setting | undefined {
    const stmt = this.db.prepare('SELECT * FROM settings WHERE key = ?');
    return stmt.get(key) as Setting | undefined;
  }

  setSetting(key: string, value: string): Setting {
    const stmt = this.db.prepare(`
      INSERT INTO settings (key, value)
      VALUES (?, ?)
      ON CONFLICT (key) DO UPDATE SET
        value = excluded.value,
        updated_at = strftime('%s', 'now')
      RETURNING *
    `);
    return stmt.get(key, value) as Setting;
  }

  getAllSettings(): Record<string, string> {
    const stmt = this.db.prepare('SELECT key, value FROM settings');
    const settings = stmt.all() as Array<{ key: string; value: string }>;
    return Object.fromEntries(settings.map(s => [s.key, s.value]));
  }

  // User operations
  getUser(id: string): User | undefined {
    const stmt = this.db.prepare('SELECT * FROM users WHERE id = ?');
    return stmt.get(id) as User | undefined;
  }

  getUserByDiscordId(discordId: string): User | undefined {
    const stmt = this.db.prepare('SELECT * FROM users WHERE discord_id = ?');
    return stmt.get(discordId) as User | undefined;
  }

  createUser(user: Omit<User, 'created_at' | 'updated_at'>): User {
    const stmt = this.db.prepare(`
      INSERT INTO users (id, discord_id, username, avatar, role)
      VALUES (?, ?, ?, ?, ?)
      RETURNING *
    `);
    return stmt.get(
      user.id,
      user.discord_id || null,
      user.username,
      user.avatar || null,
      user.role
    ) as User;
  }

  updateUser(id: string, updates: Partial<Pick<User, 'username' | 'avatar' | 'role' | 'discord_id'>>): User | undefined {
    const stmt = this.db.prepare(`
      UPDATE users
      SET username = COALESCE(?, username),
          avatar = COALESCE(?, avatar),
          role = COALESCE(?, role),
          discord_id = COALESCE(?, discord_id)
      WHERE id = ?
      RETURNING *
    `);
    return stmt.get(
      updates.username,
      updates.avatar,
      updates.role,
      updates.discord_id,
      id
    ) as User | undefined;
  }

  // Migration helper
  saveKanbanData(boardId: string, lists: KanbanListData[]): void {
    const transaction = this.db.transaction(() => {
      // Delete existing data for this board
      this.db.prepare('DELETE FROM cards WHERE list_id IN (SELECT id FROM lists WHERE board_id = ?)').run(boardId);
      this.db.prepare('DELETE FROM lists WHERE board_id = ?').run(boardId);

      // Insert lists and cards
      lists.forEach((list, listIndex) => {
        this.createList({
          id: list.id,
          board_id: boardId,
          title: list.title,
          type: list.type,
          position: listIndex,
          card_limit: list.cardLimit
        });

        list.cards.forEach((card, cardIndex) => {
          this.createCard({
            id: card.id,
            list_id: list.id,
            title: card.title,
            description: card.description,
            position: cardIndex,
            due_date: card.dueDate ? Math.floor(new Date(card.dueDate).getTime() / 1000) : undefined,
            labels: card.labels,
            attachments: card.attachments,
            members: card.members
          });
        });
      });
    });

    transaction();
  }

  // Helper to convert CardRow to KanbanCardData
  private convertCardRowToKanbanCard(cardRow: CardRow): KanbanCardData {
    return {
      id: cardRow.id,
      title: cardRow.title,
      description: cardRow.description || undefined,
      labels: cardRow.labels ? JSON.parse(cardRow.labels) : undefined,
      dueDate: cardRow.due_date ? new Date(cardRow.due_date * 1000) : undefined,
      attachments: cardRow.attachments ? JSON.parse(cardRow.attachments) : undefined,
      members: cardRow.members ? JSON.parse(cardRow.members) : undefined
    };
  }
}

// Export singleton instance
export const dbService = new DatabaseService();